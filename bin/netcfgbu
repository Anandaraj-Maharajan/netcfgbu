#!/usr/bin/env python

# -----------------------------------------------------------------------------
# System Imports
# -----------------------------------------------------------------------------

import sys
import asyncio
from importlib import metadata
from collections import defaultdict, Counter
from errno import errorcode
from operator import itemgetter
from textwrap import indent
from itertools import zip_longest

# -----------------------------------------------------------------------------
# Public Imports
# -----------------------------------------------------------------------------

import click
from tabulate import tabulate

# -----------------------------------------------------------------------------
# Private Imports
# -----------------------------------------------------------------------------

import netcfgbu
from netcfgbu.netcfgbu_ssh import ConfigBackupSSHSpec, set_max_startups
from netcfgbu import netcfgbu_config
from netcfgbu.os_specs import make_host_os_spec
from netcfgbu.logger import get_logger, stop_aiologging
from netcfgbu.probe import probe
from netcfgbu.aiofut import as_completed

import netcfgbu.inventory

VERSION = metadata.version(netcfgbu.__package__)


LN_SEP = "# " + "-" * 78
SPACES_4 = " " * 4


# #############################################################################
#
#                                CODE BEGINS
#
# #############################################################################


# def make_batches(tasks, batch_n=None):
#     if not batch_n:
#         return [tasks]
#
#     args = [iter(tasks)] * batch_n
#     batches = list(zip_longest(*args))
#     if None in batches[-1]:
#         batches[-1] = [coro for coro in batches[-1] if coro]
#
#     get_logger().info(f"BATCHING by {batch_n}, COUNT: {len(batches)}")
#     return batches


def err_reason(exc):
    if isinstance(exc, OSError):
        return errorcode[exc.errno]
    elif isinstance(exc, asyncio.TimeoutError):
        return "TIMEOUT - device failed to connect via SSH"
    else:
        return "%s: %s" % (str(exc.__class__.__name__), str(exc))


def print_report(report, total_n):

    fail_n = len(report["fail"])
    ok_n = len(report["ok"])
    err_n = len(report["error"])

    print(LN_SEP)
    print(f"Summary: TOTAL={total_n}, OK={ok_n}, FAIL={fail_n}, ERROR={err_n}")

    if fail_n:
        print(f"\n\nFAIL: ({fail_n})")
        print(
            tabulate(
                headers=["host", "os_name"],
                tabular_data=[[rec["host"], rec["os_name"]] for rec in report["FAIL"]],
            )
        )

    if err_n:
        print(f"\n\nERRORS: ({err_n})")
        print(
            tabulate(
                headers=["host", "os_name", "reason"],
                tabular_data=[
                    [rec["host"], rec["os_name"], err_reason(exc)]
                    for rec, exc in report["error"]
                ],
            )
        )

    print(LN_SEP)


# -----------------------------------------------------------------------------
#
#                                EXEC BACKUP
#
# -----------------------------------------------------------------------------


def exec_backup(app_cfg, inventory_recs, cli_opts):

    backup_tasks = dict()

    log = get_logger()

    backup_tasks = {
        make_host_os_spec(rec, app_cfg).backup_config(): rec for rec in inventory_recs
    }

    total = len(backup_tasks)
    report = defaultdict(list)
    done = 0

    async def process_batch():
        nonlocal done
        async for task in as_completed(backup_tasks):
            done += 1
            coro = task.get_coro()
            rec = backup_tasks[coro]
            msg = f"DONE ({done}/{total}): {rec['host']} "

            try:
                task.result()
                log.info(msg + ": OK")
                report['ok'].append(rec)

            except Exception as exc:
                report["error"].append((rec, exc))
                log.error(msg + f": {str(exc)}")

    loop = asyncio.get_event_loop()
    loop.run_until_complete(process_batch())
    stop_aiologging()
    print_report(report, len(inventory_recs))


# -----------------------------------------------------------------------------
#
#                                EXEC LOGIN
#
# -----------------------------------------------------------------------------


def exec_test_login(app_cfg, inventory_recs, cli_opts):

    login_tasks = {
        make_host_os_spec(rec, app_cfg).test_login(): rec for rec in inventory_recs
    }

    if (batch_n := cli_opts["batch"]) is not None:
        set_max_startups(batch_n)

    total = len(login_tasks)

    report = defaultdict(list)
    done = 0
    log = get_logger()

    async def process_batch():
        nonlocal done

        async for task in as_completed(login_tasks):
            done += 1
            coro = task.get_coro()
            rec = login_tasks[coro]
            msg = f"DONE ({done}/{total}): {rec['host']} "
            try:
                if login_user := task.result():
                    log.info(msg + f"with user {login_user}")
                    report["ok"].append(rec)
                else:
                    log.warning(msg + "NO LOGIN")
                    report["fail"].append(rec)

            except Exception as exc:
                if isinstance(exc, asyncio.TimeoutError):
                    log.warning(msg + "Timeout")
                    report['fail'].append(rec)
                else:
                    report["error"].append((rec, exc))
                    log.error(msg + f": {err_reason(exc)}")

    loop = asyncio.get_event_loop()
    loop.run_until_complete(process_batch())
    stop_aiologging()
    print_report(report, len(login_tasks))


# -----------------------------------------------------------------------------
#
#                                EXEC PROBE
#
# -----------------------------------------------------------------------------


def exec_probe(inventory):
    inv_n = len(inventory)
    log = get_logger()
    log.info(f"Checking SSH reachability on {inv_n} devices ...")

    tasks = dict()
    loop = asyncio.get_event_loop()
    tasks = {probe(rec.get("ipaddr") or rec.get("host")): rec for rec in inventory}
    report = defaultdict(list)

    async def proces_check():
        async for probe_task in as_completed(tasks):
            try:
                task_coro = probe_task.get_coro()
                rec = tasks[task_coro]
                probe_ok = "ok" if probe_task.result() else "fail"
                report[probe_ok].append(rec)

            except OSError as exc:
                probe_ok = "error"
                report["error"].append((rec, exc))

            log.info(f"{rec['host']}: {probe_ok}")

    loop.run_until_complete(proces_check())
    stop_aiologging()
    print_report(report, len(tasks))


# -----------------------------------------------------------------------------
#
#                                    CLI
#
# -----------------------------------------------------------------------------


opt_config_file = click.option(
    "-C", "--config", envvar="NETCFGBU_CONFIG", type=click.File()
)

opt_limits = click.option("--limit", "-l", multiple=True, help="limit inventory",)

opt_batch = click.option(
    "--batch",
    "-b",
    type=click.IntRange(1, 500),
    help="inevntory record processing batch size",
)


@click.group()
@click.version_option(version=VERSION)
def cli():
    pass


@cli.command(name="backup")
@opt_config_file
@opt_limits
@opt_batch
def cli_backup(**cli_opts):
    app_cfg = netcfgbu_config.load(fileio=cli_opts["config"])

    inventory_recs = netcfgbu.inventory.load(app_cfg=app_cfg, limits=cli_opts["limit"])
    exec_backup(app_cfg=app_cfg, inventory_recs=inventory_recs, cli_opts=cli_opts)


# -----------------------------------------------------------------------------
#                                Probe Test Command
# -----------------------------------------------------------------------------


@cli.command(name="probe")
@opt_config_file
@opt_limits
def cli_check(**cli_opts):
    """
    Probe each device for SSH reachablility.

    The probe check determines if the device is reachable and the SSH port
    is available to receive connections.
    """
    app_cfg = netcfgbu_config.load(fileio=cli_opts["config"])

    if not cli_opts["limit"]:
        value = click.prompt("Process full inventory, are you sure? [n/Y]", default="n")
        if value != "Y":
            sys.exit("aborting.")

    inventory_recs = netcfgbu.inventory.load(app_cfg=app_cfg, limits=cli_opts["limit"])

    if not inventory_recs:
        sys.exit("No inventory matching limits.")

    exec_probe(inventory_recs)


# -----------------------------------------------------------------------------
#                                Login Test Command
# -----------------------------------------------------------------------------


@cli.command(name="login")
@opt_config_file
@opt_limits
@opt_batch
def cli_login(**cli_opts):
    """
    Verify SSH login to devices.
    """
    app_cfg = netcfgbu_config.load(fileio=cli_opts["config"])
    inventory_recs = netcfgbu.inventory.load(app_cfg=app_cfg, limits=cli_opts["limit"])

    exec_test_login(app_cfg, inventory_recs, cli_opts)


# -----------------------------------------------------------------------------
#                                Inventory Commands
# -----------------------------------------------------------------------------


@cli.group(name="inventory")
def cli_inventory():
    pass


@cli_inventory.command("ls")
@opt_config_file
@opt_limits
@click.option("--brief", is_flag=True)
def cli_inventory_list(**cli_opts):

    app_cfg = netcfgbu_config.load(fileio=cli_opts["config"])

    inventory_recs = netcfgbu.inventory.load(app_cfg=app_cfg, limits=cli_opts["limit"])

    os_names = Counter(rec["os_name"] for rec in inventory_recs)

    os_name_table = indent(
        tabulate(
            headers=["os_name", "count"],
            tabular_data=sorted(os_names.items(), key=itemgetter(1), reverse=True),
        ),
        SPACES_4,
    )

    print(LN_SEP)
    print(
        f"""
SUMMARY: TOTAL={len(inventory_recs)}
BY OS-NAME:
{os_name_table}
"""
    )

    if cli_opts["brief"] is True:
        return

    print(
        tabulate(
            headers=["host", "os_name"],
            tabular_data=[[rec["host"], rec["os_name"]] for rec in inventory_recs],
        )
    )


@cli_inventory.command("build")
@opt_config_file
@click.option("--name", "-n", help="inventory name")
@click.option("--brief", is_flag=True)
def cli_inventory_build(**cli_opts):
    """
    Build the inventory file.

    If the netcfgbu configuraiton file contains inventory definitions then you
    can use this command to the script to build the inventory.
    """
    from netcfgbu.cli.inventory import build

    app_cfg = netcfgbu_config.load(fileio=cli_opts["config"])
    try:
        inv_df = app_cfg["inventory"][0]
    except IndexError:
        sys.exit("No inventory defined in configuration file")

    build(inv_df)


if __name__ == "__main__":
    cli()
